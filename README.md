# SpringBoot와 MongoDB를 사용하여 채팅서버 만들기

* 비동기 환경 (Reactive)

<hr>

> RDBMS
* 관계형 데이터베이스 관리 시스템 (공유와 중복제거가 키워드)
* 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스
* 다른 테이블들과 관계를 맺고 모여있는 집합체
* 외래키를 사용해 테이블 간 join이 가능하단 큰 특징을 가지고 있다.
* 데이터 구조가 명확하고 명확한 스키마가 중요한 경우, 
  또한 중복된 데이터가 없어 변경이 용이하기 때문에 
  관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합
#### 장점
* 정해진 스키마에 따라 데이터를 저장 -> 명확한 데이터 구조
* 각 데이터를 중복없이 한번만 저장할 수 있다. -> 변경 범위가 한곳
* 시스템이 커질경우 복잡해질 수 있다.
#### 단점
* 성능 향상을 위해 Scale-up만 지원 -> 비용이 늘어난다.
* 스키마가 변경될 경우 번거로워진다.

<hr>

> MongoDB(NoSQL)
* 컬렉션 형태
* RDBMS와 달리 테이블 간 관계를 정의하지 않음
* RDBMS의 단점인 성능 향상을 위해 등장
* 데이터 일관성은 포기하되 비용을 고려하여 여러 대의 데이터에 분산하여 저장하는 Scale-Out을 목표로 등장
* Key Value Database 
    - 데이터가 key, value 쌍으로 저장됨
    - 질의 속도가 굉장히 빠르다.
    - Redis, Riak, Amazon Dynamo DB 등
* Key Document Database 
    - Key. Document 형태로 저장
    - Value가 계층형태의 도큐먼트로 저장됨 => 객체지향에서의 객체와 유사, 
      즉 하나의 객체를 여러 개의 테이블에 나눠 저장할 필요가 없다.
    - 객체-관계 매핑이 필요하지 않다. (객체를 도큐먼트 형태로 바로 저장하기 떄문)
    - 검색에 최적화되어 있다.
    - MongoDB, CouthDB 등
* Wide Column Database
    - Key 에서 필드를 결정
    - HBase, Hypertable 등
* Graph Database 
    - 데이터를 Node, Edge, Property와 함께 그래프 구조를 사용해 저장
    - 관계형 모델이라 할 수 있다. 데이터 간의 관계가 탐색의 키일 경우 적합하다.
    - Neo4J 등
* 정확한 데이트 구조를 알 수 없는 경우, 단, 변경이 많이 이루어지지 않는 시스템이 좋다.
  또한 막대한 데이터를 저장해야 되는 시스템에 적합
#### 장점
* 데이터를 찾을 때 퍼포먼스가 좋다.
* 스키마가 없어 자유로운 데이터 구조
* 언제든 데이터를 조정하고 추가할 수 있다.
* Scale-Out 도 가능하다.

#### 단점
* 데이터 중복이 발생할 수 있다. (일관성이 깨질 수 있다.)
* 명확한 데이터 구조를 보장하지 않는다.

<hr>

> 비동기 서버(Netty)
* 기본적으로 스프링은 서블릿 기반 스프링 ==> request 요청마다 스레드가 만들어진다
* 규모가 커질수록 부하가 커지고 스레드가 많아질수록 문맥교환(컨텍스트 스위칭)이 많아지고 
  시간을 쪼개서 왔다갔다하는 Time Slicing이 많아진다. ==> 결국 속도가 느려진다.
* 최소한의 스레드(스레드풀)로 돌리는 비동기 서버를 사용할 경우 문맥교환이 적어서 속도가 빠르다.
* 비동기 서버를 사용할 경우 DB도 비동기여야 한다. (R2DBC or MongoDB)

<hr>

### 웹소켓과 SSE
> 웹소켓
* 양방향 통신 (요청을 보내지 않더라도 서버에서 알아서 클라이언트로 데이터를 보내준다)
* WS프로토콜을 사용 (http 프로토콜이 사용하는 포트와 공유가 되기때문에 다른 포트에 따로 연결해줄 필요는 없다)

> SSE
* 서버에서 클라이언트로 데이터를 보내는 단방향 통신
